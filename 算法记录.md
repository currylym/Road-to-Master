
# 经典算法题记录
<!-- TOC -->

- [经典算法题记录](#经典算法题记录)
    - [矩阵相关](#矩阵相关)
        - [1矩形面积](#1矩形面积)
        - [2最短路径](#2最短路径)
    - [字符串相关](#字符串相关)
        - [1.最小公共子串](#1最小公共子串)
        - [2.编辑距离](#2编辑距离)

<!-- /TOC -->
## 矩阵相关

### 1矩形面积

- 柱状图中最大矩形（**84，困难**）
    >**题目：** 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

    **暴力法**:
    ***
    ```
    #思路1：索引i和j围成的矩形面积为s=(j-i+1)*min(heights[i:j+1])
    class Solution:
        def largestRectangleArea(self, heights: List[int]) -> int:
            #暴力法
            if not heights:return 0
            res = 0
            for i in range(0,len(heights)):
                Min = heights[i]
                for j in range(i,len(heights)):
                    Min = min(Min,heights[j])
                    res = max(res,(j-i+1)*Min)
                    #print(i,j,Min)
            return res
    #改进：第二次循环可以将j移到最后一个大于Min的位置，避免多余计算。
    ```
    ```
    #思路2：以索引i为中心向左右扩展，找到左右最后一个大于heights[i]的索引left和right，此时矩形面积为s=heights[i]*(right-left+1).矩形意义是以heights[i]为高能围成的最大矩形。
    ```
    **进阶**：
    ***
    >**单调栈**：单调栈是一种特殊的栈，栈内元素保持递增或者递减。
    单调栈有两个性质：
    1.满足从栈顶到栈底的元素具有严格的单调性
    2.满足栈的后进先出特性越靠近栈底的元素越早进栈
    利用单调栈，可以找到从左/右遍历第一个比它小/大的元素的位置，在某些问题中可以将时间复杂度从O(N^2)降低为O(N)  
    维护逻辑：元素大于栈顶进栈，小于则栈顶出栈直到栈顶小于该元素
    ```
    #stack存元素的索引
    class Solution(object):
        def largestRectangleArea(self, heights):
            heights.append(-1)
            stack = []
            maxArea = 0
            for i in range(len(heights)):
                while stack and heights[stack[-1]] > heights[i]:
                    height = heights[stack.pop()]
                    width = i if not stack else i-stack[-1]-1
                    maxArea = max(maxArea,height*width)
                stack.append(i)
                #print(stack)
            return maxArea
    ```

- 矩阵中最大长方形（**85，困难**）
    >**题目**：给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

    >思路：对每一行求出向上的连续为1的柱状图，使用题目84的解法即可。

    ```
    class Solution:
    
        def largestRectangleArea(self, heights):
            heights.append(-1)
            stack = []
            maxArea = 0
            for i in range(len(heights)):
                while stack and heights[stack[-1]] > heights[i]:
                    height = heights[stack.pop()]
                    width = i if not stack else i-stack[-1]-1
                    maxArea = max(maxArea,height*width)
                stack.append(i)
                #print(stack)
            return maxArea
        
        #柱状图采取递归的方式求
        def maximalRectangle(self, matrix: List[List[str]]) -> int:
            if not matrix:return 0
            last = [int(i) for i in matrix[0]]
            res = self.largestRectangleArea(last)
            for i in range(1,len(matrix)):
                heights = [int(i)+j if int(i) > 0 else 0 for i,j in zip(matrix[i],last)]
                print(heights)
                res = max(res,self.largestRectangleArea(heights))
                last = heights
            return res
    ```
- 矩阵中最大正方形（**221，中等**）
    >**题目**：在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

    >思路1：沿用最大长方形的思路，面积计算修改。
    ```
    class Solution:

        def largestRectangleArea(self, heights):
            heights.append(-1)
            stack = []
            maxArea = 0
            for i in range(len(heights)):
                while stack and heights[stack[-1]] > heights[i]:
                    height = heights[stack.pop()]
                    width = i if not stack else i-stack[-1]-1
                    #修改面积计算公式
                    maxArea = max(maxArea,min(height,width)**2)
                stack.append(i)
                #print(stack)
            return maxArea
    
        #柱状图采取递归的方式求
        def maximalSquare(self, matrix: List[List[str]]) -> int:
            if not matrix:return 0
            last = [int(i) for i in matrix[0]]
            res = self.largestRectangleArea(last)
            for i in range(1,len(matrix)):
                heights = [int(i)+j if int(i) > 0 else 0 for i,j in zip(matrix[i],last)]
                print(heights)
                res = max(res,self.largestRectangleArea(heights))
                last = heights
            return res
    ```

    >思路2：直接动态规划  
    <br>定义dp矩阵，dp[i][j]表示以第i行第j列为右下角的正方形的最大边长。则有递推关系如下</br>
    `if matrix[i][j] == 0:dp[i][j] = 0`  
    `if matrix[i][j] != 0:dp[i][j]=1+min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])`
    注：补充全零的行列，便于计算。
    ```
    class Solution {

        public int maximalSquare(char[][] matrix) {
            int m = matrix.length;
            if(m < 1) return 0;
            int n = matrix[0].length;
            int max = 0;
            int[][] dp = new int[m+1][n+1];
        
            for(int i = 1; i <= m; ++i) {
                for(int j = 1; j <= n; ++j) {
                    if(matrix[i-1][j-1] == '1') {
                        dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                        max = Math.max(max, dp[i][j]); 
                    }
                }
            }

            return max*max;
        }
    }   
    ```
    

### 2最短路径

## 字符串相关

### 1.最小公共子串

### 2.编辑距离

> **题目**：给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符/删除一个字符/替换一个字符

>**思路**：动态规划。建立dp矩阵，`dp[i][j]`表示`string1[:i]`和`string2[:j]`的编辑距离。则有如下递推关系： 
<br>`dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(string1[i-1] != string2[j-1]))`
<br>**矩阵初始化**：`dp[0][j]=j`,`dp[i][0]=i`
<br>**解释**：在计算`string1[:i]`和`string2[:j]`的编辑距离时，对其末尾有如下四种处理方式，对应递推式右边的四种情况。
>>1.删掉`string1[i-1]`  
>>2.删掉`string2[j-1]`  
>>3.同时删掉`string1[i-1]`和`string2[j-1]`  
>>4.同时保留`string1[i-1]`和`string2[j-1]`,此时有`string1[i-1] == string2[j-1]    

```
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        
        if not word1:
            return len(word2)
        if not word2:
            return len(word1)
        
        dp = [[0]*(len(word2)+1) for _ in range(len(word1)+1)]
        
        for i in range(len(word1)):
            dp[i+1][0] = i+1
        for j in range(len(word2)):
            dp[0][j+1] = j+1
        #print(dp)
        for i in range(1,len(word1)+1):
            for j in range(1,len(word2)+1):
                #print(i,j)
                dp[i][j] = min(dp[i-1][j-1]+(word1[i-1]!=word2[j-1]),dp[i-1][j]+1,dp[i][j-1]+1)
        return dp[-1][-1]
```

