
# 经典算法题记录

## 矩阵相关

### 1矩形面积

- 柱状图中最大矩形（**84，困难**）
    >**题目：** 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

    **暴力法**:
    ***
    ```
    #思路1：索引i和j围成的矩形面积为s=(j-i+1)*min(heights[i:j+1])
    class Solution:
        def largestRectangleArea(self, heights: List[int]) -> int:
            #暴力法
            if not heights:return 0
            res = 0
            for i in range(0,len(heights)):
                Min = heights[i]
                for j in range(i,len(heights)):
                    Min = min(Min,heights[j])
                    res = max(res,(j-i+1)*Min)
                    #print(i,j,Min)
            return res
    #改进：第二次循环可以将j移到最后一个大于Min的位置，避免多余计算。
    ```
    ```
    #思路2：以索引i为中心向左右扩展，找到左右最后一个大于heights[i]的索引left和right，此时矩形面积为s=heights[i]*(right-left+1).矩形意义是以heights[i]为高能围成的最大矩形。
    ```
    **进阶**：
    ***
    >**单调栈**：单调栈是一种特殊的栈，栈内元素保持递增或者递减。
    单调栈有两个性质：
    1.满足从栈顶到栈底的元素具有严格的单调性
    2.满足栈的后进先出特性越靠近栈底的元素越早进栈
    利用单调栈，可以找到从左/右遍历第一个比它小/大的元素的位置，在某些问题中可以将时间复杂度从O(N^2)降低为O(N)  
    维护逻辑：元素大于栈顶进栈，小于则栈顶出栈直到栈顶小于该元素
    ```
    #stack存元素的索引
    class Solution(object):
        def largestRectangleArea(self, heights):
            heights.append(-1)
            stack = []
            maxArea = 0
            for i in range(len(heights)):
                while stack and heights[stack[-1]] > heights[i]:
                    height = heights[stack.pop()]
                    width = i if not stack else i-stack[-1]-1
                    maxArea = max(maxArea,height*width)
                stack.append(i)
                #print(stack)
            return maxArea
    ```

- 矩阵中最大长方形（）
    >给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

### 2最短路径

## 字符串相关

### 1.最小公共子串

### 2.编辑距离