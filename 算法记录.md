
# 经典算法题记录（动态规划）
<!-- TOC -->

- [经典算法题记录（动态规划）](#经典算法题记录动态规划)
    - [1.1. 矩阵相关](#11-矩阵相关)
        - [1.1.1. 矩形面积](#111-矩形面积)
        - [1.1.2. 最短路径](#112-最短路径)
    - [1.2. 字符串相关](#12-字符串相关)
        - [1.2.1. 最小公共子串](#121-最小公共子串)
        - [1.2.2. 编辑距离（**189，困难**）](#122-编辑距离189困难)
        - [1.2.3. 两个字符串的删除操作（**583，中等**）](#123-两个字符串的删除操作583中等)
        - [1.2.4. 回文系列](#124-回文系列)
    - [1.3. 斐波拉其数列原型](#13-斐波拉其数列原型)
    - [1.4. 其他动态规划](#14-其他动态规划)

<!-- /TOC -->

## 1.1. 矩阵相关

### 1.1.1. 矩形面积

- 柱状图中最大矩形（**84，困难**）
    >**题目：** 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

    **暴力法**:
    ***
    ```
    #思路1：索引i和j围成的矩形面积为s=(j-i+1)*min(heights[i:j+1])
    class Solution:
        def largestRectangleArea(self, heights: List[int]) -> int:
            #暴力法
            if not heights:return 0
            res = 0
            for i in range(0,len(heights)):
                Min = heights[i]
                for j in range(i,len(heights)):
                    Min = min(Min,heights[j])
                    res = max(res,(j-i+1)*Min)
                    #print(i,j,Min)
            return res
    #改进：第二次循环可以将j移到最后一个大于Min的位置，避免多余计算。
    ```
    ```
    #思路2：以索引i为中心向左右扩展，找到左右最后一个大于heights[i]的索引left和right，此时矩形面积为s=heights[i]*(right-left+1).矩形意义是以heights[i]为高能围成的最大矩形。
    ```
    **进阶**：
    ***
    >**单调栈**：单调栈是一种特殊的栈，栈内元素保持递增或者递减。
    单调栈有两个性质：
    1.满足从栈顶到栈底的元素具有严格的单调性
    2.满足栈的后进先出特性越靠近栈底的元素越早进栈
    利用单调栈，可以找到从左/右遍历第一个比它小/大的元素的位置，在某些问题中可以将时间复杂度从O(N^2)降低为O(N)  
    维护逻辑：元素大于栈顶进栈，小于则栈顶出栈直到栈顶小于该元素
    ```
    #stack存元素的索引
    class Solution(object):
        def largestRectangleArea(self, heights):
            heights.append(-1)
            stack = []
            maxArea = 0
            for i in range(len(heights)):
                while stack and heights[stack[-1]] > heights[i]:
                    height = heights[stack.pop()]
                    width = i if not stack else i-stack[-1]-1
                    maxArea = max(maxArea,height*width)
                stack.append(i)
                #print(stack)
            return maxArea
    ```

- 矩阵中最大长方形（**85，困难**）
    >**题目**：给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

    >思路：对每一行求出向上的连续为1的柱状图，使用题目84的解法即可。

    ```
    class Solution:
    
        def largestRectangleArea(self, heights):
            heights.append(-1)
            stack = []
            maxArea = 0
            for i in range(len(heights)):
                while stack and heights[stack[-1]] > heights[i]:
                    height = heights[stack.pop()]
                    width = i if not stack else i-stack[-1]-1
                    maxArea = max(maxArea,height*width)
                stack.append(i)
                #print(stack)
            return maxArea
        
        #柱状图采取递归的方式求
        def maximalRectangle(self, matrix: List[List[str]]) -> int:
            if not matrix:return 0
            last = [int(i) for i in matrix[0]]
            res = self.largestRectangleArea(last)
            for i in range(1,len(matrix)):
                heights = [int(i)+j if int(i) > 0 else 0 for i,j in zip(matrix[i],last)]
                print(heights)
                res = max(res,self.largestRectangleArea(heights))
                last = heights
            return res
    ```
- 矩阵中最大正方形（**221，中等**）
    >**题目**：在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

    >思路1：沿用最大长方形的思路，面积计算修改。
    ```
    class Solution:

        def largestRectangleArea(self, heights):
            heights.append(-1)
            stack = []
            maxArea = 0
            for i in range(len(heights)):
                while stack and heights[stack[-1]] > heights[i]:
                    height = heights[stack.pop()]
                    width = i if not stack else i-stack[-1]-1
                    #修改面积计算公式
                    maxArea = max(maxArea,min(height,width)**2)
                stack.append(i)
                #print(stack)
            return maxArea
    
        #柱状图采取递归的方式求
        def maximalSquare(self, matrix: List[List[str]]) -> int:
            if not matrix:return 0
            last = [int(i) for i in matrix[0]]
            res = self.largestRectangleArea(last)
            for i in range(1,len(matrix)):
                heights = [int(i)+j if int(i) > 0 else 0 for i,j in zip(matrix[i],last)]
                print(heights)
                res = max(res,self.largestRectangleArea(heights))
                last = heights
            return res
    ```

    >思路2：直接动态规划  
    <br>定义dp矩阵，dp[i][j]表示以第i行第j列为右下角的正方形的最大边长。则有递推关系如下</br>
    `if matrix[i][j] == 0:dp[i][j] = 0`  
    `if matrix[i][j] != 0:dp[i][j]=1+min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])`  
    注：补充全零的行列，便于计算。
    ```
    class Solution {

        public int maximalSquare(char[][] matrix) {
            int m = matrix.length;
            if(m < 1) return 0;
            int n = matrix[0].length;
            int max = 0;
            int[][] dp = new int[m+1][n+1];
        
            for(int i = 1; i <= m; ++i) {
                for(int j = 1; j <= n; ++j) {
                    if(matrix[i-1][j-1] == '1') {
                        dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                        max = Math.max(max, dp[i][j]); 
                    }
                }
            }

            return max*max;
        }
    }   
    ```
    

### 1.1.2. 最短路径

## 1.2. 字符串相关

### 1.2.1. 最小公共子串

### 1.2.2. 编辑距离（**189，困难**）

> **题目**：给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符/删除一个字符/替换一个字符

>**思路**：动态规划。建立dp矩阵，`dp[i][j]`表示`string1[:i]`和`string2[:j]`的编辑距离。则有如下递推关系： 
<br>`dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(string1[i-1] != string2[j-1]))`
<br>**矩阵初始化**：`dp[0][j]=j`,`dp[i][0]=i`
<br>**解释**：在计算`string1[:i]`和`string2[:j]`的编辑距离时，对其末尾有如下四种处理方式，对应递推式右边的四种情况。
>>1.删掉`string1[i-1]`  
>>2.删掉`string2[j-1]`  
>>3.同时删掉`string1[i-1]`和`string2[j-1]`  
>>4.同时保留`string1[i-1]`和`string2[j-1]`,此时有`string1[i-1] == string2[j-1]`

```
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        
        if not word1:
            return len(word2)
        if not word2:
            return len(word1)
        
        dp = [[0]*(len(word2)+1) for _ in range(len(word1)+1)]
        
        for i in range(len(word1)):
            dp[i+1][0] = i+1
        for j in range(len(word2)):
            dp[0][j+1] = j+1
        #print(dp)
        for i in range(1,len(word1)+1):
            for j in range(1,len(word2)+1):
                #print(i,j)
                dp[i][j] = min(dp[i-1][j-1]+(word1[i-1]!=word2[j-1]),dp[i-1][j]+1,dp[i][j-1]+1)
        return dp[-1][-1]
```

### 1.2.3. 两个字符串的删除操作（**583，中等**）
>**题目**：给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

>**思路**：和编辑距离的思路一致。唯一不同的是，在`string1[i-1] ！= string2[j-1]`时，删除操作的步数加2。

```
#略
```

### 1.2.4. 回文系列

1. 最长回文子串（**5，中等**）
>**题目**：给定一个字符串 s，找到 s 中最长的回文子串

>**思路**：s前加上标记字符#，建立dp数组，`dp[i]`指以`s[dp[i-1]]`为结尾的最长回文子串。则有如下递推关系：  
`if s[i] == s[i-1-dp[i-1]]:dp[i]=2+dp[i-1]`  
`if s[i] != s[i-1-dp[i-1]]:dp[i]=max(i-j+1，j从i-1-dp[i-1]取到i使得s[j:i+1]是回文串)`  
注：第二种情况j的取值不能超出以s[i-1]为结尾的最长回文子串的范围，否则最长的定义相悖。

```
class Solution:
    def longestPalindrome(self, s: str) -> str:
    
        #判断回文串
        def is_palindromic(string):
            start = 0
            end = len(string)-1
            while start < end:
                if string[start] != string[end]:
                    return False
                start += 1
                end -= 1
            return True
        
        s = '#' + s
        dp = [0]*(len(s))
        
        for i in range(1,len(s)):
            if s[i] == s[i-1-dp[i-1]]:
                dp[i] = 2 + dp[i-1]
            else:
                for j in range(i-1-dp[i-1],i+1):
                    if is_palindromic(s[j:i+1]):
                        dp[i] = i-j+1
                        break
        Max = max(dp)
        for i in range(len(dp)):
            if dp[i] == Max:
                return s[i-Max+1:i+1]
```

2. 最长回文子序列（**516，中等**）

> **题目**：给定一个字符串s，找到其中最长的回文子序列。

> **思路**：建立dp矩阵，`dp[i][j]`表示`s[i:j+1]`的最长回文序列长度，则递推关系如下：  
> `dp[i][j] = max(dp[i+1][j],dp[i][j-1],dp[i+1][j-1]+2*(s[i] == s[j]))`  
> 注：dp应该依对角线更新。

```
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        
        if not s:return 0
        if s == s[::-1]:return len(s)
        
        df = [[0]*len(s) for _ in range(len(s))]
        
        for i in range(len(s)):
            df[i][i] = 1
    
        for margin in range(1,len(s)):
            for i in range(len(s)-margin):
                j = i + margin
                #print(i,j)
                df[i][j] = max(df[i+1][j],df[i][j-1],df[i+1][j-1]+2*(s[i] == s[j]))
        
        return df[0][len(s)-1]
```

## 1.3. 斐波拉其数列原型

## 1.4. 其他动态规划

