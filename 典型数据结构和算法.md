<!-- TOC -->

- [1. 栈和队列](#1-栈和队列)
- [2. 链表](#2-链表)
    - [2.1. 原地删除列表节点（）](#21-原地删除列表节点)
    - [2.2. 回文链表（）](#22-回文链表)
- [3. 字符串](#3-字符串)
    - [3.1. KMP](#31-kmp)
- [4. 二叉树](#4-二叉树)
- [5. 图](#5-图)
- [6. 排序](#6-排序)
    - [6.1. 快排（3分）](#61-快排3分)
    - [6.2. 堆排](#62-堆排)
    - [6.3. 归并排序](#63-归并排序)
- [7. 搜索](#7-搜索)
- [8. 常数时间数据结构](#8-常数时间数据结构)

<!-- /TOC -->

# 1. 栈和队列



# 2. 链表

## 2.1. 原地删除列表节点（）

> **题目**：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

> **思路**：把下一节点拷贝到当前节点然后删除下一节点。

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val, node.next = node.next.val, node.next.next
```

## 2.2. 回文链表（）

> **题目**：请判断一个链表是否为回文链表。

> **思路**：

```

```

# 3. 字符串

## 3.1. KMP

# 4. 二叉树

# 5. 图

# 6. 排序

## 6.1. 快排（3分）

## 6.2. 堆排

```
def heapify(unsorted, index, heap_size):
    largest = index
    left_index = 2 * index + 1
    right_index = 2 * index + 2
    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:
        largest = left_index

    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:
        largest = right_index

    if largest != index:
        unsorted[largest], unsorted[index] = unsorted[index], unsorted[largest]
        heapify(unsorted, largest, heap_size)


def heap_sort(unsorted):
    n = len(unsorted)
    for i in range(n // 2 - 1, -1, -1):
        heapify(unsorted, i, n)
    for i in range(n - 1, 0, -1):
        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]
        heapify(unsorted, 0, i)
    return unsorted
```

## 6.3. 归并排序

```
def merge_sort(collection):
    #两路归并排序
    length = len(collection)
    if length > 1:
        midpoint = length // 2
        left_half = merge_sort(collection[:midpoint])
        right_half = merge_sort(collection[midpoint:])
        i = 0
        j = 0
        k = 0
        left_length = len(left_half)
        right_length = len(right_half)
        while i < left_length and j < right_length:
            if left_half[i] < right_half[j]:
                collection[k] = left_half[i]
                i += 1
            else:
                collection[k] = right_half[j]
                j += 1
            k += 1

        while i < left_length:
            collection[k] = left_half[i]
            i += 1
            k += 1

        while j < right_length:
            collection[k] = right_half[j]
            j += 1
            k += 1

    return collection
```

# 7. 搜索

# 8. 常数时间数据结构