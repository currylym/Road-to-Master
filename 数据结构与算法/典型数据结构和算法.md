<!-- TOC -->

- [1. 栈和队列](#1-栈和队列)
    - [1.1. 迷宫问题](#11-迷宫问题)
        - [1.1.1. 路径是否存在](#111-路径是否存在)
        - [1.1.2. 最短路径](#112-最短路径)
    - [1.2. 表达式计算](#12-表达式计算)
        - [1.2.1. 中缀转后缀](#121-中缀转后缀)
        - [1.2.2. 后缀表达式计算](#122-后缀表达式计算)
    - [1.3. 最小栈相关题](#13-最小栈相关题)
    - [1.4. 岛屿问题](#14-岛屿问题)
- [2. 数组](#2-数组)
    - [2.1. 重复元素系列](#21-重复元素系列)
        - [2.1.1. 找所有重复元素（元素只出现一次或两次）（**442，中等**）](#211-找所有重复元素元素只出现一次或两次442中等)
        - [2.1.2. 数组中出现次数超过一半的元素](#212-数组中出现次数超过一半的元素)
        - [2.1.3. 在数组中找到出现次数大于N/k的数](#213-在数组中找到出现次数大于nk的数)
    - [2.2. 逆序对（**剑指offer**）](#22-逆序对剑指offer)
    - [2.3. 划分为k个相等子集](#23-划分为k个相等子集)
    - [2.4. 最长等差序列](#24-最长等差序列)
    - [2.5. 数组的中位数](#25-数组的中位数)
- [3. 链表](#3-链表)
    - [3.1. 原地删除列表节点（）](#31-原地删除列表节点)
    - [3.2. 回文链表](#32-回文链表)
    - [3.3. 链表排序](#33-链表排序)
    - [3.4. 相交链表](#34-相交链表)
- [4. 字符串](#4-字符串)
    - [4.1. KMP](#41-kmp)
    - [4.2. 典型题目](#42-典型题目)
        - [4.2.1. 判断两个字符串是否互为旋转词（**796，简单**）](#421-判断两个字符串是否互为旋转词796简单)
        - [4.2.2. K 距离间隔重排字符串](#422-k-距离间隔重排字符串)
- [5. 二叉树](#5-二叉树)
    - [5.1. 二叉树遍历](#51-二叉树遍历)
        - [5.1.1. 前序](#511-前序)
        - [5.1.2. 中序](#512-中序)
        - [5.1.3. 后序](#513-后序)
        - [5.1.4. 层次](#514-层次)
    - [5.2. 二叉树序列化和反序列化](#52-二叉树序列化和反序列化)
    - [5.3. 二叉搜索树第k大元素](#53-二叉搜索树第k大元素)
    - [5.4. 判断二叉树是否是完全二叉树](#54-判断二叉树是否是完全二叉树)
    - [5.5. 判断二叉树是否是满二叉树](#55-判断二叉树是否是满二叉树)
    - [5.6. 判断二叉树是不是二叉搜索树](#56-判断二叉树是不是二叉搜索树)
    - [5.7. 二叉树和为某一值的路径](#57-二叉树和为某一值的路径)
    - [5.8. 判断平衡二叉树](#58-判断平衡二叉树)
    - [5.9. 树中两个节点的最临近公共祖先](#59-树中两个节点的最临近公共祖先)
- [6. 图](#6-图)
    - [6.1. 拓扑排序](#61-拓扑排序)
    - [6.2. bellman-ford](#62-bellman-ford)
    - [6.3. dijkstra](#63-dijkstra)
    - [6.4. floyd](#64-floyd)
    - [6.5. SPFA](#65-spfa)
- [7. BFS/DFS](#7-bfsdfs)
- [8. 排序](#8-排序)
    - [8.1. 快排（3分）](#81-快排3分)
    - [8.2. 堆排](#82-堆排)
    - [8.3. 归并排序](#83-归并排序)
- [9. 二分查找](#9-二分查找)
    - [9.1. 数组中的重复元素（**287，中等**）](#91-数组中的重复元素287中等)
    - [9.2. 旋转数组的最小元素（**剑指offer**）](#92-旋转数组的最小元素剑指offer)
    - [9.3. 二分法找元素第一次和最后一次出现位置](#93-二分法找元素第一次和最后一次出现位置)
- [10. 双指针](#10-双指针)
    - [10.1. 数组中两数和为s的所有组合](#101-数组中两数和为s的所有组合)
    - [10.2. 数组中子数组和为s的所有组合](#102-数组中子数组和为s的所有组合)
- [11. 大数据算法](#11-大数据算法)
    - [11.1. bitmap和布隆过滤器](#111-bitmap和布隆过滤器)
    - [11.2. 数学](#112-数学)
        - [11.2.1. 从1到n元素1出现的次数](#1121-从1到n元素1出现的次数)
- [12. 位运算](#12-位运算)
    - [12.1. 交换两个数（剑指offer）](#121-交换两个数剑指offer)
    - [12.2. 不用加减乘除实现加法（剑指offer）](#122-不用加减乘除实现加法剑指offer)
    - [12.3. 数组中只出现一次的数（两个）](#123-数组中只出现一次的数两个)
- [13. 其它](#13-其它)
    - [13.1. LRU缓存机制](#131-lru缓存机制)
    - [13.2. 最大频率栈](#132-最大频率栈)
    - [13.3. 排列组合](#133-排列组合)

<!-- /TOC -->

# 1. 栈和队列

## 1.1. 迷宫问题

### 1.1.1. 路径是否存在

```
DFS/BFS均可。
找单条路径或者所有路径使用DFS较好。BFS需要额外记录前面走过的位置。
```

### 1.1.2. 最短路径

```
BFS
```

## 1.2. 表达式计算

### 1.2.1. 中缀转后缀

### 1.2.2. 后缀表达式计算

## 1.3. 最小栈相关题


## 1.4. 岛屿问题

> 

# 2. 数组

## 2.1. 重复元素系列

### 2.1.1. 找所有重复元素（元素只出现一次或两次）（**442，中等**）

> **题目**：给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。找到所有出现两次的元素。你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗。

> **思路**：

```python

```

### 2.1.2. 数组中出现次数超过一半的元素
> 使用partition或2.1.3的思路

### 2.1.3. 在数组中找到出现次数大于N/k的数
> 思路：维护一个容量为k的字典，一旦字典满了，则将所有元素减1，为0的元素删掉。最后再对剩下的元素进行正确性判断。

## 2.2. 逆序对（**剑指offer**）

> **题目**：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。

> **思路**：分治法，类似于归并排序。

```python
class Solution:
    def __init__(self):
        self.count = 0
    def _InversePairs(self, data):
        # write code here
        
        if len(data) <= 1:
            return data
        
        mid = len(data)//2
        left = self._InversePairs(data[:mid])
        right = self._InversePairs(data[mid:])
        
        sorting = []
        i = 0
        j = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                sorting.append(left[i])
                i += 1
                self.count += j
            else:
                sorting.append(right[j])
                j += 1
        while i < len(left):
            sorting.append(left[i])
            self.count += len(right)
            i += 1
        while j < len(right):
            sorting.append(right[j])
            j += 1
        
        return sorting
    
    def InversePairs(self, data):
        self.count = 0
        self._InversePairs(data)
        return self.count % 1000000007
```

## 2.3. 划分为k个相等子集
```python

```

## 2.4. 最长等差序列

> 暴力法
```python
class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        
        self.res = 1
        
        # 递归
        def helper(A,seq):
            if len(A)+len(seq) <= self.res:
                return
            if not A:
                self.res = max(self.res,len(seq))
                return
            if len(seq) >= 2:
                for i in range(len(A)):
                    if A[i]-seq[-1] == seq[-1]-seq[-2]:
                        seq.append(A[i])
                helper([],seq)
            else:
                helper(A[1:],seq+[A[0]])
                helper(A[1:],seq)
        
        # 暴力
        n = len(A)
        for i in range(n):
            for j in range(i+1,n):
                tmp = [A[i],A[j]]
                for m in range(j+1,n):
                    if tmp[-1]-A[m] == tmp[-2]-tmp[-1]:
                        tmp.append(A[m])
                self.res = max(self.res,len(tmp))
        
        #helper(A,[])
        return self.res
```

> 空间换时间
```python
class Solution:
    def longestArithSeqLength(self, A: List[int]) -> int:
        ret,arr=1,[{} for i in range(len(A))]
        for i in range(1,len(A)):
            for j in range(i):
                d=A[i]-A[j]
                n=arr[j].get(d,1)+1
                arr[i][d]=n
            ret=max(ret,max(arr[i].values()))
        return ret
```

## 2.5. 数组的中位数
> partition
```python

```

# 3. 链表

## 3.1. 原地删除列表节点（）

> **题目**：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

> **思路**：把下一节点拷贝到当前节点然后删除下一节点。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val, node.next = node.next.val, node.next.next
```

## 3.2. 回文链表

> **题目**：请判断一个链表是否为回文链表。

> **思路**：

```
# 分成两段，链表反转，看链表元素是否依次相等。
```

## 3.3. 链表排序

> **题目**：对链表进行排序

> **思路1**：归并排序

```
# 切分链表
# 合并有序链表
```

> **思路2**：快速排序
```
# partition:
# partition需要修改
```

## 3.4. 相交链表

# 4. 字符串

## 4.1. KMP

```python
def kmp(pattern, text):
    """
    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text
    with complexity O(n + m)

    1) Preprocess pattern to identify any suffixes that are identical to prefixes

        This tells us where to continue from if we get a mismatch between a character in our pattern
        and the text.

    2) Step through the text one character at a time and compare it to a character in the pattern
        updating our location within the pattern if necessary

    """

    # 1) Construct the failure array
    failure = get_failure_array(pattern)

    # 2) Step through text searching for pattern
    i, j = 0, 0  # index into text, pattern
    while i < len(text):
        if pattern[j] == text[i]:
            if j == (len(pattern) - 1):
                return True
            j += 1

        # if this is a prefix in our pattern
        # just go back far enough to continue
        elif j > 0:
            j = failure[j - 1]
            continue
        i += 1
    return False


def get_failure_array(pattern):
    """
    Calculates the new index we should go to if we fail a comparison
    :param pattern:
    :return:
    """
    failure = [0]
    i = 0
    j = 1
    while j < len(pattern):
        if pattern[i] == pattern[j]:
            i += 1
        elif i > 0:
            i = failure[i-1]
            continue
        j += 1
        failure.append(i)
    return failure
```

## 4.2. 典型题目

### 4.2.1. 判断两个字符串是否互为旋转词（**796，简单**）

> **题目**：给定两个字符串, A 和 B。A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。

> **思路**：原问题等价于B是否是A+A的子串。使用KMP算法即可。

```
#略
```

### 4.2.2. K 距离间隔重排字符串
> 题目：给你一个非空的字符串 s 和一个整数 k，你要将这个字符串中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离至少为 k。

```python
class Solution:
    def rearrangeString(self, s: str, k: int) -> str:
        from collections import Counter
        import heapq
        if k == 0 or k == 1: return s
        heap = []
        for a, b in Counter(s).items():
            heapq.heappush(heap, (-b, a))
        res = ""
        while heap:
            tmp = []
            for _ in range(k):
                if not heap:
                    if len(res) == len(s):
                        return res
                    else:
                        return ""
                b, a = heapq.heappop(heap)
                res += a
                tmp.append((b + 1, a))
            for b, a in tmp:
                if b != 0:
                    heapq.heappush(heap, (b, a))
        return res
```

# 5. 二叉树

## 5.1. 二叉树遍历

### 5.1.1. 前序
```python
class Solution:  
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        result = list()
        if root == None:
            return result
        
        stack = list()
        stack.append(root)
        while len(stack) != 0:
            top = stack.pop()
            if top.right != None:
                stack.append(top.right)
            if top.left != None:
                stack.append(top.left)
            result.append(top.val)
           
        return result
```

### 5.1.2. 中序
```python
class Solution:  
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        result = list()
        if root == None:
            return result
        
        stack = list()
        while stack or root:
            if root != None:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop()
                result.append(root.val)
                root = root.right

        return result
```

### 5.1.3. 后序
```python
class Solution:
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        result = list()
        if root == None:
            return result
        
        stack = list()
        while stack or root:
            if root:
                stack.append(root)
                result.insert(0, root.val)
                root = root.right
            else:
                node = stack.pop()
                root = node.left
                
        return result
```

### 5.1.4. 层次

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        if not root:
            return []
        stack = [(root,0)]
        res = []
        while stack:
            node,depth = stack.pop(0)
            if depth >= len(res):
                res.append([node.val])
            else:
                res[depth].append(node.val)
            if node.left:
                stack.append((node.left,depth+1))
            if node.right:
                stack.append((node.right,depth+1))
        return res
```

## 5.2. 二叉树序列化和反序列化

## 5.3. 二叉搜索树第k大元素
```python
# 非递归中序遍历，提前终止
class Solution:
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        result = list()
        stack = list()
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop()
                result.append(root.val)
                if len(result) >= k:
                    break
                root = root.right

        return result[k-1]
```

## 5.4. 判断二叉树是否是完全二叉树
> **完全二叉树**：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

> 思路：层次遍历。所有节点应该被某一个左右节点不都存在的点分成两部分，前面的节点左右节点都存在，后面的节点左右节点都不存在。

## 5.5. 判断二叉树是否是满二叉树

> **满二叉树**：每一层的节点数都达到最大个数

> 思路：层次遍历。两种节点：前面节点的左右节点都存在，后面节点的左右节点都不存在。

## 5.6. 判断二叉树是不是二叉搜索树

> 思路：中序遍历。如果遍历时一直递增则为二叉搜索树，否则不是。

## 5.7. 二叉树和为某一值的路径

## 5.8. 判断平衡二叉树

```python
# 在递归计算二叉树的深度时保留一个全局的flag
class Solution:

    def IsBalanced_Solution(self, pRoot):
        self.flag = True
        self.tree_Iteration(pRoot)
        return self.flag

    def tree_Iteration(self, pRoot):
        if not pRoot or self.flag==False:
            return 0
        left = self.tree_Iteration(pRoot.left)
        right = self.tree_Iteration(pRoot.right)
        if abs(left-right)>1:
            self.flag = False
        return left+1 if left>right else right+1
```

## 5.9. 树中两个节点的最临近公共祖先
几种情况
> 二叉搜索树
> 有父指针的多叉树
> 一般的树

```python
```

# 6. 图

## 6.1. 拓扑排序
- DFS

- BFS

## 6.2. bellman-ford 
## 6.3. dijkstra 
## 6.4. floyd 
## 6.5. SPFA

# 7. BFS/DFS

# 8. 排序

## 8.1. 快排（3分）

```python
def quick_sort_3partition(sorting, left, right):
    if right <= left:
        return
    a = i = left
    b = right
    pivot = sorting[left]
    while i <= b:
        if sorting[i] < pivot:
            sorting[a], sorting[i] = sorting[i], sorting[a]
            a += 1
            i += 1
        elif sorting[i] > pivot:
            sorting[b], sorting[i] = sorting[i], sorting[b]
            b -= 1
        else:
            i += 1
    quick_sort_3partition(sorting, left, a - 1)
    quick_sort_3partition(sorting, b + 1, right)
```

## 8.2. 堆排

```python
def heapify(unsorted, index, heap_size):
    largest = index
    left_index = 2 * index + 1
    right_index = 2 * index + 2
    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:
        largest = left_index

    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:
        largest = right_index

    if largest != index:
        unsorted[largest], unsorted[index] = unsorted[index], unsorted[largest]
        heapify(unsorted, largest, heap_size)

# 思想是：每次取出堆顶元素，更新堆，一直循环即可得到排序好的结果
def heap_sort(unsorted):
    n = len(unsorted)
    for i in range(n // 2 - 1, -1, -1):
        heapify(unsorted, i, n)
    for i in range(n - 1, 0, -1):
        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]
        heapify(unsorted, 0, i)
    return unsorted
```

> 拓展：堆数据结构
```python
class heap:
    def __init__(self):
        self.heap = []

    # 节点上浮
    def down(self,item):
        pass

    # 节点下沉
    def up(self):
        pass
```

## 8.3. 归并排序

```python
def merge_sort(collection):
    #两路归并排序
    length = len(collection)
    if length > 1:
        midpoint = length // 2
        left_half = merge_sort(collection[:midpoint])
        right_half = merge_sort(collection[midpoint:])
        i = 0
        j = 0
        k = 0
        left_length = len(left_half)
        right_length = len(right_half)
        while i < left_length and j < right_length:
            if left_half[i] < right_half[j]:
                collection[k] = left_half[i]
                i += 1
            else:
                collection[k] = right_half[j]
                j += 1
            k += 1

        while i < left_length:
            collection[k] = left_half[i]
            i += 1
            k += 1

        while j < right_length:
            collection[k] = right_half[j]
            j += 1
            k += 1

    return collection
```

# 9. 二分查找

## 9.1. 数组中的重复元素（**287，中等**）

> **题目**：给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

> **思路**：二分法。

## 9.2. 旋转数组的最小元素（**剑指offer**）

> **思路**：二分查找。

## 9.3. 二分法找元素第一次和最后一次出现位置

# 10. 双指针

## 10.1. 数组中两数和为s的所有组合

## 10.2. 数组中子数组和为s的所有组合

# 11. 大数据算法

## 11.1. bitmap和布隆过滤器

```python

```

## 11.2. 数学

### 11.2.1. 从1到n元素1出现的次数

> 思路：使用递归实现。f(x)表示1到x中元素1出现的次数。则对于n（位数为m，首位n0），则f(n)=f(n-n0*10**(m-1))+10*(m-1)+n0*(m-1)*10**(m-2)

# 12. 位运算

## 12.1. 交换两个数（剑指offer）

## 12.2. 不用加减乘除实现加法（剑指offer）

```python
class Solution:
    def Add(self, num1, num2):
        MAX = 0x7FFFFFFF
        mask = 0xFFFFFFFF
        while num2 != 0:
            num1, num2 = (num1 ^ num2), ((num1 & num2) << 1)
            num1 = num1 & mask
            num2 = num2 & mask
        return num1 if num1 <= MAX else ~(num1 ^ mask)
```

## 12.3. 数组中只出现一次的数（两个）
> 思路：先求所有数的异或，由于有两个只出现一次的数，则异或结果肯定不为0。根据异或结果不为0的某一位把所有元素分成两组，对于每组再使用异或即可。

# 13. 其它
## 13.1. LRU缓存机制
> 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。
> - **获取数据 get(key)**：如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
> - **写入数据 put(key, value)**：如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

> **思路1**：log使用栈结构，记录历史操作的key
> 需要考虑的有几个点：
> （1）调用get方法时，如果key在log里面，则将key移到log末尾
> （2）调用put方法时，如果cache还没满且key出现在log里面，同样需要把key移到log末尾
> （3）调用put方法时，如果cache满了，key在log里面则将key移到log末端，更新cache；key不在log里面，则删除log尾端的key，更新log和cache
```python
class LRUCache:

    def __init__(self, capacity: int):
        self.cache = {}
        self.capacity = capacity
        self.log = []

    def get(self, key: int) -> int:
        val = self.cache.get(key,-1)
        if key in self.log:
            self.log.remove(key)
            self.log.append(key)
        #print('after get (%s):'%key,self.log,self.cache)
        return val

    def put(self, key: int, value: int) -> None:
        if len(self.cache) < self.capacity:
            if key in self.log:
                self.log.remove(key)
            self.cache[key] = value
            self.log.append(key)
        else:
            if key not in self.cache:
                dele = self.log.pop(0)
                del self.cache[dele]
            else:
                self.log.remove(key)
            self.log.append(key)
            self.cache[key] = value
        #print('after put(%s,%s):'%(key,value),self.log,self.cache)
```

> **思路2**；采用hash表和双链表实现。主要是克服栈无法把某一元素在常数时间内移到栈尾部的缺点
```python
class ListNode:
    def __init__(self, key=None, value=None):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None


class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.hashmap = {}
        # 新建两个节点 head 和 tail
        self.head = ListNode()
        self.tail = ListNode()
        # 初始化链表为 head <-> tail
        self.head.next = self.tail
        self.tail.prev = self.head

    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法
    def move_node_to_tail(self, key):
            # 先将哈希表key指向的节点拎出来，为了简洁起名node
            #      hashmap[key]                               hashmap[key]
            #           |                                          |
            #           V              -->                         V
            # prev <-> node <-> next         pre <-> next   ...   node
            node = self.hashmap[key]
            node.prev.next = node.next
            node.next.prev = node.prev
            # 之后将node插入到尾节点前
            #                 hashmap[key]                 hashmap[key]
            #                      |                            |
            #                      V        -->                 V
            # prev <-> tail  ...  node                prev <-> node <-> tail
            node.prev = self.tail.prev
            node.next = self.tail
            self.tail.prev.next = node
            self.tail.prev = node

    def get(self, key: int) -> int:
        if key in self.hashmap:
            # 如果已经在链表中了久把它移到末尾（变成最新访问的）
            self.move_node_to_tail(key)
        res = self.hashmap.get(key, -1)
        if res == -1:
            return res
        else:
            return res.value

    def put(self, key: int, value: int) -> None:
        if key in self.hashmap:
            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点
            # 但是需要更新字典该值对应节点的value
            self.hashmap[key].value = value
            # 之后将该节点移到末尾
            self.move_node_to_tail(key)
        else:
            if len(self.hashmap) == self.capacity:
                # 去掉哈希表对应项
                self.hashmap.pop(self.head.next.key)
                # 去掉最久没有被访问过的节点，即头节点之后的节点
                self.head.next = self.head.next.next
                self.head.next.prev = self.head
            # 如果不在的话就插入到尾节点前
            new = ListNode(key, value)
            self.hashmap[key] = new
            new.prev = self.tail.prev
            new.next = self.tail
            self.tail.prev.next = new
            self.tail.prev = new
```

## 13.2. 最大频率栈
> 实现 FreqStack，模拟类似栈的数据结构的操作的一个类。
> FreqStack 有两个函数：
> - **push(int x)**，将整数 x 推入栈中。
> - **pop()**，它移除并返回栈中出现最频繁的元素。如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。

```python
class FreqStack:

    def __init__(self):
        self.freq = {}
        self.group = {}
        self.maxfreq = 0

    def push(self, x: int) -> None:
        self.freq[x] = self.freq.get(x,0) + 1
        self.maxfreq = max(self.maxfreq,self.freq[x])
        if self.freq[x] in self.group:
            self.group[self.freq[x]].append(x)
        else:
            self.group[self.freq[x]] = [x]

    def pop(self) -> int:
        val = self.group[self.maxfreq].pop(-1)
        self.freq[val] -= 1
        if not self.group[self.maxfreq]:
            self.maxfreq -= 1
        return val
```

## 13.3. 排列组合
```python
def combine(nums,k):
    res = []
    if k == 0:
        return [[]]
    if k > len(nums):
        return []
    for i in range(len(nums)):
        res.extend([[nums[i]]+j for j in combine(nums[i+1:],k-1)])
    return res

combine([1,2,3,4],3)

def permutation(nums,k):
    res = []
    if k == 0:
        return [[]]
    if k > len(nums):
        return []
    for i in range(len(nums)):
        res.extend([[nums[i]]+j for j in permutation(nums[:i]+nums[i+1:],k-1)])
    return res

permutation([1,2,3,4],3)
```