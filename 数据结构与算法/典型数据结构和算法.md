<!-- TOC -->

- [1. 栈和队列](#1-栈和队列)
    - [1.1. 迷宫问题](#11-迷宫问题)
        - [1.1.1. 路径是否存在](#111-路径是否存在)
        - [1.1.2. 最短路径](#112-最短路径)
    - [1.2. 表达式计算](#12-表达式计算)
        - [1.2.1. 中缀转后缀](#121-中缀转后缀)
        - [1.2.2. 后缀表达式计算](#122-后缀表达式计算)
- [2. 数组](#2-数组)
    - [2.1. 重复元素系列](#21-重复元素系列)
        - [2.1.1. 找所有重复元素（元素只出现一次或两次）（**442，中等**）](#211-找所有重复元素元素只出现一次或两次442中等)
    - [2.2. 逆序对（**剑指offer**）](#22-逆序对剑指offer)
- [3. 链表](#3-链表)
    - [3.1. 原地删除列表节点（）](#31-原地删除列表节点)
    - [3.2. 回文链表（）](#32-回文链表)
    - [3.3. 链表排序](#33-链表排序)
- [4. 字符串](#4-字符串)
    - [4.1. KMP](#41-kmp)
    - [4.2. 典型题目](#42-典型题目)
        - [4.2.1. 判断两个字符串是否互为旋转词（**796，简单**）](#421-判断两个字符串是否互为旋转词796简单)
- [5. 二叉树](#5-二叉树)
    - [5.1. 二叉树遍历](#51-二叉树遍历)
    - [5.2. 二叉树序列化和反序列化](#52-二叉树序列化和反序列化)
- [6. 图](#6-图)
    - [6.1.](#61)
- [7. 排序](#7-排序)
    - [7.1. 快排（3分）](#71-快排3分)
    - [7.2. 堆排](#72-堆排)
    - [7.3. 归并排序](#73-归并排序)
- [8. 二分查找](#8-二分查找)
    - [8.1. 数组中的重复元素（**287，中等**）](#81-数组中的重复元素287中等)
    - [8.2. 旋转数组的最小元素（**剑指offer**）](#82-旋转数组的最小元素剑指offer)
    - [8.3. 二分法找元素第一次和最后一次出现位置](#83-二分法找元素第一次和最后一次出现位置)
- [9. 常数时间数据结构](#9-常数时间数据结构)
- [10. 大数据算法](#10-大数据算法)
    - [10.1. bitmap和布隆过滤器](#101-bitmap和布隆过滤器)
- [11. 位运算](#11-位运算)
    - [11.1. 交换两个数（剑指offer）](#111-交换两个数剑指offer)
    - [11.2. 不用加减乘除实现加法（剑指offer）](#112-不用加减乘除实现加法剑指offer)

<!-- /TOC -->

# 1. 栈和队列

## 1.1. 迷宫问题

### 1.1.1. 路径是否存在

```
DFS/BFS均可。
找单条路径或者所有路径使用DFS较好。BFS需要额外记录前面走过的位置。
```

### 1.1.2. 最短路径

```
BFS
```

## 1.2. 表达式计算

### 1.2.1. 中缀转后缀

### 1.2.2. 后缀表达式计算

# 2. 数组

## 2.1. 重复元素系列

### 2.1.1. 找所有重复元素（元素只出现一次或两次）（**442，中等**）

> **题目**：给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。找到所有出现两次的元素。你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗。

> **思路**：

```

```

## 2.2. 逆序对（**剑指offer**）

> **题目**：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。

> **思路**：分治法，类似于归并排序。

```
class Solution:
    def __init__(self):
        self.count = 0
    def _InversePairs(self, data):
        # write code here
        
        if len(data) <= 1:
            return data
        
        mid = len(data)//2
        left = self._InversePairs(data[:mid])
        right = self._InversePairs(data[mid:])
        
        sorting = []
        i = 0
        j = 0
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
                sorting.append(left[i])
                i += 1
                self.count += j
            else:
                sorting.append(right[j])
                j += 1
        while i < len(left):
            sorting.append(left[i])
            self.count += len(right)
            i += 1
        while j < len(right):
            sorting.append(right[j])
            j += 1
        
        return sorting
    
    def InversePairs(self, data):
        self.count = 0
        self._InversePairs(data)
        return self.count % 1000000007
```

# 3. 链表

## 3.1. 原地删除列表节点（）

> **题目**：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

> **思路**：把下一节点拷贝到当前节点然后删除下一节点。

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val, node.next = node.next.val, node.next.next
```

## 3.2. 回文链表（）

> **题目**：请判断一个链表是否为回文链表。

> **思路**：

```
# 分成两段，链表反转，看链表元素是否依次相等。
```

## 3.3. 链表排序

> **题目**：对链表进行排序

> **思路**：归并排序

```
#切分链表
#合并有序链表
```

# 4. 字符串

## 4.1. KMP

```
def kmp(pattern, text):
    """
    The Knuth-Morris-Pratt Algorithm for finding a pattern within a piece of text
    with complexity O(n + m)

    1) Preprocess pattern to identify any suffixes that are identical to prefixes

        This tells us where to continue from if we get a mismatch between a character in our pattern
        and the text.

    2) Step through the text one character at a time and compare it to a character in the pattern
        updating our location within the pattern if necessary

    """

    # 1) Construct the failure array
    failure = get_failure_array(pattern)

    # 2) Step through text searching for pattern
    i, j = 0, 0  # index into text, pattern
    while i < len(text):
        if pattern[j] == text[i]:
            if j == (len(pattern) - 1):
                return True
            j += 1

        # if this is a prefix in our pattern
        # just go back far enough to continue
        elif j > 0:
            j = failure[j - 1]
            continue
        i += 1
    return False


def get_failure_array(pattern):
    """
    Calculates the new index we should go to if we fail a comparison
    :param pattern:
    :return:
    """
    failure = [0]
    i = 0
    j = 1
    while j < len(pattern):
        if pattern[i] == pattern[j]:
            i += 1
        elif i > 0:
            i = failure[i-1]
            continue
        j += 1
        failure.append(i)
    return failure
```

## 4.2. 典型题目

### 4.2.1. 判断两个字符串是否互为旋转词（**796，简单**）

> **题目**：给定两个字符串, A 和 B。A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。

> **思路**：原问题等价于B是否是A+A的子串。使用KMP算法即可。

```
#略
```

# 5. 二叉树

## 5.1. 二叉树遍历

### 5.1.1. 前序

### 5.1.2. 中序

### 5.1.3. 后序

### 5.1.4. 层次

## 5.2. 二叉树序列化和反序列化

## 5.3. 二叉搜索树第k大元素

# 6. 图

## 6.1. 拓扑排序
- DFS

- BFS

# 7. 排序

## 7.1. 快排（3分）

```
def quick_sort_3partition(sorting, left, right):
    if right <= left:
        return
    a = i = left
    b = right
    pivot = sorting[left]
    while i <= b:
        if sorting[i] < pivot:
            sorting[a], sorting[i] = sorting[i], sorting[a]
            a += 1
            i += 1
        elif sorting[i] > pivot:
            sorting[b], sorting[i] = sorting[i], sorting[b]
            b -= 1
        else:
            i += 1
    quick_sort_3partition(sorting, left, a - 1)
    quick_sort_3partition(sorting, b + 1, right)
```

## 7.2. 堆排

```
def heapify(unsorted, index, heap_size):
    largest = index
    left_index = 2 * index + 1
    right_index = 2 * index + 2
    if left_index < heap_size and unsorted[left_index] > unsorted[largest]:
        largest = left_index

    if right_index < heap_size and unsorted[right_index] > unsorted[largest]:
        largest = right_index

    if largest != index:
        unsorted[largest], unsorted[index] = unsorted[index], unsorted[largest]
        heapify(unsorted, largest, heap_size)


def heap_sort(unsorted):
    n = len(unsorted)
    for i in range(n // 2 - 1, -1, -1):
        heapify(unsorted, i, n)
    for i in range(n - 1, 0, -1):
        unsorted[0], unsorted[i] = unsorted[i], unsorted[0]
        heapify(unsorted, 0, i)
    return unsorted
```

## 7.3. 归并排序

```
def merge_sort(collection):
    #两路归并排序
    length = len(collection)
    if length > 1:
        midpoint = length // 2
        left_half = merge_sort(collection[:midpoint])
        right_half = merge_sort(collection[midpoint:])
        i = 0
        j = 0
        k = 0
        left_length = len(left_half)
        right_length = len(right_half)
        while i < left_length and j < right_length:
            if left_half[i] < right_half[j]:
                collection[k] = left_half[i]
                i += 1
            else:
                collection[k] = right_half[j]
                j += 1
            k += 1

        while i < left_length:
            collection[k] = left_half[i]
            i += 1
            k += 1

        while j < right_length:
            collection[k] = right_half[j]
            j += 1
            k += 1

    return collection
```

# 8. 二分查找

## 8.1. 数组中的重复元素（**287，中等**）

> **题目**：给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

> **思路**：二分法。

## 8.2. 旋转数组的最小元素（**剑指offer**）

> **思路**：二分查找。

## 8.3. 二分法找元素第一次和最后一次出现位置

# 9. 常数时间数据结构

# 10. 大数据算法

## 10.1. bitmap和布隆过滤器

# 11. 位运算

## 11.1. 交换两个数（剑指offer）

## 11.2. 不用加减乘除实现加法（剑指offer）

```
class Solution:
    def Add(self, num1, num2):
        MAX = 0x7FFFFFFF
        mask = 0xFFFFFFFF
        while num2 != 0:
            num1, num2 = (num1 ^ num2), ((num1 & num2) << 1)
            num1 = num1 & mask
            num2 = num2 & mask
        return num1 if num1 <= MAX else ~(num1 ^ mask)
```
